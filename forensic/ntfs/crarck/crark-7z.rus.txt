Новые    версии    этой    программы   находятся    по   адресу:
http://www.crark.net.

-----------------------------------------------------------------
Изменения в версиях:

1.2
     - 64-битная версия, 32-битная больше не обновляется. Выигрыш
по скорости около 5-20% на разных типах архивов
     - карты NVIDIA G80 (compute capability 1.x) больше не
поддерживаются
     - Intel GPU не поддерживается до тех пор, пока драйвера 
OpenCL не станут работающими

1.1c
     - исправлена ошибка с AESNI на несжатых файлах

1.1a,b
     - добавлена поддержка NVIDIA Maxwell
     - поддержка Intel GPU временно отключена из-за неудовлетворительного
       качества драйвера OpenCL
     - это последняя версия, поддерживающая WinXP

1.10 - в два раза быстрее на Haswell c AVX2. CPU rate при этом =
       4.50!
     - подключение CUDA 5.5 неожиданно дало рост на 30-50% на картах
       Kepler и Fermi
     - поддержка Intel HD Graphics на OpenCL
     - улучшен код AMD XOP
     - новая опция -n для задания номера GPU

1.05 - исправлена серьезная ошибка (пароль не находился)
     - корректное определение процессоров AMD APU

1.04 - русские (и др. не-ASCII) пароли теперь работают

1.03a - исправлена ошибка OpenCL под AMD GCN с опцией -d2

1.03 - улучшены настройки под Kepler
     - индекс GPU и размер сетки GPU вычисляется более аккуратно
     - из-за большого количества ошибок в компиляторах OpenCL
       добавлено самотестирование OpenCL-кода. 

1.02 - исправлена серьезная ошибка (не находился пароль)

1.01 - повышена скорость на 3%-10% на CPU

1.0 BETA:
     - поддержка NVIDIA и AMD GPU через CUDA/OpenCL
     - еще более точное вычисление индекса CPU и тактов SHA-256
       Отключайте Turbo Boost для получения правильных результатов!

0.95 BETA:
     - добавлен код под AMD FX (Bulldozer)

0.9 BETA:
     - первая версия, вышедшая в свет.

-----------------------------------------------------------------



                        c R A R k for 7-Zip
                 (First & Fastest 7-Zip Cracker)
                            v. 1.1

         (с) Copyright PSW-soft 2012-13 by P. Semjanov


     ЭТА ВЕРСИЯ ПРОГРАММЫ РАСПРОСТРАНЯЕТСЯ "КАК ЕСТЬ". ВЫ  МОЖЕТЕ
ИСПОЛЬЗОВАТЬ ЕЕ НА СВОЙ СТРАХ И РИСК. НИКАКИЕ ПРЕТЕНЗИИ ПО РАБОТЕ
ПРОГРАММЫ  ПРИНИМАТЬСЯ  НЕ  БУДУТ.  ТАКЖЕ  АВТОР  НЕ  ГАРАНТИРУЕТ
ДАЛЬНЕЙШЕГО СОПРОВОЖДЕНИЯ И ОБНОВЛЕНИЯ ВЕРСИЙ ЭТОЙ ПРОГРАММЫ.
     Данная программа является FREEWARE и может  распространяться
свободно при соблюдении следующих условий: программный код не из-
меняется и  программа  распространяется  в  виде  дистрибутивного
архива. Любое коммерческое использование этой программы запрещено!


                1. Назначение и характеристики.

     Программа cRARk-7z предназначена для определения забытого па-
роля у 7-Zip-архивов. Программа корректно работает с архивами 7-Zip
версий выше 3.x.
     Для работы программе cRARk требуется компьютер с процессором,
поддержвающий SSE2-инструкции. Программа специально  оптимизирована
под  процессоры Core 2/Core i5/i7 и видеокарты NVIDIA серии 8xxxx и
выше, AMD/ATI Radeon серии 5xxx и выше.
     Скорость при полном переборе у программы составляет около 150
паролей/сек  на  современном  мощном  компьютере, откуда следует,
что  реально перебором  можно взломать  пароли не длиннее 6-ти
символов. На видеокартах скорость может достигать 4000 паролей в
секунду.
   Скорость работы при атаке по словарю и при  восстановлении не-
правильно  набранного  пароля  составляет  около 50 паролей/сек.
Видеокарты в этих режимах не поддерживаются.


               2. Требования ко входному архиву.

     Для  успешной  работы  программы  для испытуемого 7z-архива
должны выполняться следующие требования:
     - должен быть по крайней мере один зашифрованный файл;
     - длина пароля не должна првышать 25 символов (для перебора
на GPU)
     В случае solid-архивов,  этим требованиям должен  удовлетво-
рять первый файл.
     Программа cRARk должна работать с многотомными (см. вопрос 5
в FAQ), саморазворачивающимися и архивами с зашифрованными именами
файлов.
     Eсли файлы в архиве шифровались с разными паролями, то будет
найден первый, соответствующий выбранному файлу.

                    3. Работа с программой.

      Для работы с программой в желаемом режиме надо создать файл
описания паролей (см. п. 4). После этого для запуска  используйте
команду:

         crark-7z [опции] архив

     Найденный пароль выдается на экран в виде:

truepass - CRC OK

     Далее он повторяется в шестнадцатеричном PCL-виде (см. 4.2.1).
Это удобно, если пароль имеет непечатаемые символы.
     Все остальные сообщения паролями НЕ ЯВЛЯЮТСЯ и предназначены
только для индикации того, что программа не зависла.

     Опциями в этом режиме являются:

    -lXX - установить длину пароля не менее, чем XX (XX = 0..127,
по умолчанию = 1).  Этот параметр  влияет на длину пароля только,
если при его описании использовался символ '*' (cм. п. 4.2.1);
    -gXX - установить длину  пароля не  более XX (XX = 0..127, по
умолчанию = 5);
    -pXXXXX - задать имя  файла описания паролей (по  умолчанию -
"PASSWORD.DEF").
    -b  - выполнить измерение производительности (benchmark);
    -v  - отобразить использованные наборы символов для проверки,
насколько правильно вы их задали. Также эта опция генерирует  все
пароли  в  соответствии  с  их  описанием, но вместо тестирования
выводит их на экран, чтобы вы могли проверить правильность их оп-
ределения;
    -nX - использовать GPU номер X;
    -fWXY - использовать криптофукнции с номерами W,X,Y
(например, -f011). Эта опция только для продвинутых пользователей
для экспериментов со скоростью программы. Некоторую информацию о
имеющихся номерах криптофункций можно получить с помощью опции -b.


     4. Выбор режима работы и множества паролей с помощью
                    файла описания паролей.

    Файл  описания  паролей  (password  definition file) является
главным управляющим файлом. Его трансляция и собственно обработка
является основной задачей библиотеки PCL. Его формат независим от
приложения, к которому подключена PCL, поэтому эта библиотека мо-
жет быть использована  с любой программой,  занимающейся подбором
паролей.

              4.1. Формат файла описания паролей.

    Файл описания паролей является обычным текстовым файлом, сос-
тоящем из  двух частей:  описания словарей  и наборов  символов и
описания паролей, разделяемых строкой из двух символов '##':

    [ <описание словарей и наборов символов> ]
    ##
    <описание паролей>

    Первая часть может отсутствовать, тогда файл должен начинать-
ся с символов '##'.
    При этом в  любом другом месте  символ '#' считается  началом
комментария. Пробелы и табуляции в файле описаний игнорируются  и
могут разделять любые компоненты.
    Для удобства вначале, в отличие от последовательности  описа-
ний в файле, рассмотрим механизм описания паролей, а затем описа-
ние наборов символов.

                     4.2. Описание паролей.

    Это главная часть  файла, ОБЯЗАТЕЛЬНО ПРИСУТСТВУЮЩАЯ  В ЛЮБОМ
ФАЙЛЕ ОПИСАНИЯ ПАРОЛЕЙ (PASSWORD.DEF) ПОСЛЕ СТРОКИ '##',  опреде-
ляет правила  генерации  паролей,  которые и  будут проверятся  в
дальнейшем.  Она состоит  из текстовых  строк, каждая из  которых
задает свое  множество  паролей  и режим работы, т.е.  по  какому
алгоритму они будут  перебираться. Каждая строка является незави-
симой и обрабатывается  отдельно, при этом подсчитывается суммар-
ное число проверенных паролей.
    Основными компонентами описания паролей являются: наборы сим-
волов и слова из словарей.  Они задают один или несколько  симво-
лов, которые будут находится  в пароле на соответствующем  месте.

                    4.2.1. Наборы символов.

     Набор символов (charset)  - это множество  символов, которые
могут  находится  на  текущем  месте  в пароле (но находится, ес-
тественно, всего лишь один из них). К ним могут относиться:

     1) простые одиночные символы (a, b, и т.д.). Означает, что в
данной позиции пароля стоит именно этот символ;
     2) экранированные символы. Специальные символы, если они мо-
гут встретиться в пароле, должны экранироваться. Смысл совпадает
с предыдущими. К ним относятся:

     \$, \., \*, \?, \=      - '$', '.', '*', '?', '='
     \], \[, \{, \}, \(, \)  - соответствующие скобки
     \ (пробел)              - пробел
     \\                      - '\'
     \XX, где X -
          шестнадцатеричная цифра  - любой символ  через  hex-код
     \0                  - пустой  символ  (отсутствие   символа).
Обычно применяется в объединении с "настоящим" символом (см. при-
меры ниже).
     В принципе, экранироваться могут любые символы, если они  не
являются шестнадцатеричными цифрами.
     3) макросы множества символов. Означают, что в текущей пози-
ции пароля может встретиться любой из символов, входящих во  мно-
жество. Эти множества определяются в первой части файла  описаний
(см. п. 4.3.2), а обозначаются следующими символами:

     $a - маленькие латинские  буквы (если не переопределено,  то
          26 штук);
     $A - большие латинские буквы (если не переопределено, то  26
          штук);
     $! - специальные знаки  (если не переопределено, то  32 шту-
          ки);
     $1 - цифры, (если не переопределено, то 10 штук);
     $i - маленькие буквы национального алфавита (для русского  -
          33 штуки);
     $I - большие буквы национального алфавита (для русского - 33
          штуки);
     $o - другие задаваемые пользователем символы;
     ?  - любой символ (т.е. все символы, входящие в вышеперечис-
          ленные макросы);

ПРИМEЧАНИЕ: макросы $v и  $p (см. 4.3.4) нельзя  использовать для
задания паролей.
     4)  объединения  любых  из  выше перечисленных символов. За-
писывается  с  помощью  квадратных  скобок.  Смысл  совпадает   с
предыдущим. Примеры:

     [$a $A]      - любая латинская буква;
     [abc]        - или a, или b, или c;
     [$1 abcdef]  - шестнадцатеричная цифра;
     [s \0]       - или s, или ничего;
     [$a $A $1 $! $i $I $o] - эквивалентно ?.

     5)  регулярный  символ  повторения  '*'. Означает, что пред-
шествующий ему набор символов нужно  повторить 0 или более раз  в
соответствующих (следующих) позициях пароля. Примеры:

     $a *    - пароль любой длины из маленьких латинских букв;
     [ab] *  - пусто, a, b, aa, ab, ba, bb, aaa ...
     [$a $A] [$a $A $1] * - "идентификатор" - последовательность
                            букв и цифр, причем первая буква.

     Отметим, что пароль длиной 0 символов имеет определенный фи-
зический смысл, и не всегда эквивалентен отсутствию пароля.
     Длина  повторения  вычисляется  автоматически  на основе за-
данной максимальной и минимальной длины пароля с помощью опций.
Отметим, что эти параметры влияют только на длину пароля, генери-
руемого с помощью символа '*' и не учитываются, если пароль состо-
ит только из слов или статических символов.
     Рекомендуется использовать '*' как можно шире. Это связано с
тем, что  она организует  самый эффективный  перебор. Хотя, вроде
бы, с позиций логики конструкции '? *' и '? ? *' одинаковы,  пер-
вая будет перебираться быстрее.
     Текущее ограничение - '*'  может быть только последним  эле-
ментом строки.

          4.2.2. Слова из словарей и их модификаторы.

     В отличии от набора символов,  слова задают не один, а  нес-
колько символов  пароля подряд.  В библиотеке  PCL поддерживаются
два словаря: основной (где  чаще всего хранятся обычные  слова) и
пользовательский (где может хранится специфическая информация ти-
па имен собственных, дат и т.п.), хотя разницы между ними никакой
нет.
     Под словарем понимается  текстовый файл, состоящий  из слов,
разделенных символами конца строки. Могут быть использованы файлы
как DOS- (CR/LF), так и UNIX-формата (LF). Желательно (в том чис-
ле и для скорости перебора), чтобы в словарях слова были в  одном
(нижнем) регистре.
     Таким образом, существуют два макроса:

     $w - слово из основного словаря;
     $u - слово из пользовательского словаря.

     Также под слова  попадают специальные наборы  символов, т.к.
они могут иметь любую длину. Они обозначаются $s(1), $s(2), ... и
определяются спецификой задачи. Для данной программы они не нужны
и не поддерживаются.
     Как  известно,  часто  паролями  бывают  переделанные слова.
Поэтому для определения таких паролей вводится целый набор  моди-
фикаторов (modifiers) слов. К ним относятся:

     .u (upper)    - перевести в верхний регистр;
     .l (lower)    - перевести в нижний регистр;
     .t (truncate) - обрезать до заданной длины;
     .c (convert)  - преобразовать словo;
     .j (joke)     - перевести в верхний регистр некоторые буквы;
     .r (reverse)  - слово наоборот;
     .s (shrink)   - сократить  слово;
     .d (duplicate)- повторить слово 2 раза.

     Модификаторы могут иметь  параметры, записываемые в  круглых
скобках.  Для  модификаторов,  предназначенных  для  работы с от-
дельными  буквами,  можно  задавать  в  качестве  параметра номер
буквы; отсутствие параметра или нулевой параметр означает -  "все
слово". Далее, номера букв  могут задаваться как с  начала слова,
так и с конца - конец слова обозначается символом '-'.
    На сегодняшний день таких модификаторов только 3: .u, .l, .t.
Итак,

     .u  или .u(0)  -  перевести  все  слово  в  верхний регистр
(PASSWORD);
     .u(1),  .u(2)  -  перевести  только  первую  (вторую)  букву
(Password, pAssword);
     .u(-), .u(-1)  -  перевести  последнюю (предпоследнюю) букву
(passworD, passwoRd);
     .t(-1)         - обрезать последнюю букву в слове (passwor).

     Остальные модификаторы  работают только  с целыми  словами и
параметр в них задает способ модификации. На сегодняшний день оп-
ределены следующие параметры к модификаторам:

     .j(0) или .j  - перевести в  верхний регистр нечетные  буквы
(PaSsWoRd);
     .j(1) - перевести в верхний регистр четные буквы (pAsSwOrD):
     .j(2) - перевести в верхний регистр гласные буквы (pAsswOrd);
     .j(3) - перевести  в   верхний  регистр  согласные   буквы
(PaSSWoRD);
     .r(0) или .r - записать слово наоборот (drowssap);
     .s(0) или .s - сократить  слово, убрав гласные, если она  не
первая (password -> psswrd, offset -> offst);
     .d(0) или .d - записать слово два раза (passwordpassword);
     .d(1)       - добавить перевернутое слово (passworddrowssap);
     .c(<номер>) - преобразовать все буквы в слове согласно соот-
ветствующей  строке преобразования (см п. 4.3.3).

     Все модификаторы корректно будут работать как с  латинскими,
так и с национальными буквами, если будут соблюдаться правила за-
дания национальных наборов символов.
     Естественно, что модификатор может быть не единственным (ог-
раничение их числа подряд - 63, которое вряд ли возможно  преодо-
леть). Примеры (пусть $w - password):

     $w.u(1).u(-) - PassworD
     $w.s.t(4)    - pssw
     $w.t(4).s    - pss


                 4.2.3. Пермутационные скобки.

     Довольно часто встречается ситуация, что вы помните  пароль,
но он почему-то не подходит. Вероятно, вы ошиблись в его  наборе.
Для  восстановления   таких  паролей   в  программе    существует
собственный алгоритм. Считается, что ошибки при наборе могут быть
следующие: переставлены  местами две  соседние буквы  (psasword),
удалена буква  (pasword), вставлена  лишняя (passweord)  или одна
заменена на другую (passwird). Будем называть такие изменения па-
роля пермутациями (permutations).
     Для указания начала и  конца участка пароля, где  могли воз-
никнуть пермутации, применяются пермутационные скобки '{' и  '}'.
После '}' может идти число  пермутаций (по умолчанию - 1),  отде-
ленное точкой  (или в  круглых скобках).  Физический смысл  числа
пермутаций - количество одновременно допущенных ошибок. Примеры:

     {abc} - будет получено 182 (разных) пароля, из них:
             bac, acb       - 2 перестановки;
             bc, ac, bc     - 3 удаления;
             aabc, babc ... - 4 * 26 - 3 вставок;
             bbc, cbc ...   - 3 * 25 замен;
             abc            - само слово;

     {password}.2 или
     {password}(2) - получатся, в частности, такие слова,
                     как psswrod, passwdro и paasswor;

     {$w} - все слова с одной ошибкой из основного словаря.

     Примечания:
     1) Естественно, что некоторые пароли будут получены не  один
раз, причем, чем выше число пермутаций, тем больше будет повторе-
ний. В программе сделаны усилия по сокращению повторений, но  они
чисто эмпирические и проверялись только для числа пермутаций,  не
большего 2. Иначе говоря, для больших чисел нет полной увереннос-
ти, что  какой-либо пароль  не будет  ошибочно выкинут. Фанатикам
комбинаторики  предлагаю   посчитать  точное   число,   например,
{password}.3, и тогда я смогу сравнить его с полученным  програм-
мой.
     2) Для операций вставки и замены надо знать, какое множество
символов вставлять. Если в  части описаний это множество  явно не
задано (см. п. 4.3.4), то в данной программе для наборов символов
это множество формируется автоматически, исходя из того, к  каким
стандартным наборам принадлежат  символы внутри  скобок (т.е. для 
{password} вставляться будет $a, {Password} - [$a $A]).  Для слов
аналогичная операция  проводится  по  первому слову  из  словаря,
при  этом учитываются модификаторы.  Если  это множество задается 
явно, то оно и используется.
     3) Текущее ограничение - символ '{' должен обязательно  быть
первым в строке. Выражения типа good_{password} пока не поддержи-
ваются, а вот {good}_password - пожалуйста.

          4.3. Описание словарей и наборов символов.

    Все описания идут в начале файла описания паролей, до  симво-
лов '##'.

                   4.3.1. Описание словарей.

    Вначале обычно описываются используемые основной и  пользова-
тельский словарь (см. п.  4.2.2). Это необходимо делать  только в
том случае, если при описании паролей будет использоваться  слова
из словарей, т.е. $w или $u.
    Словари задаются следующим образом:

    $w = "<имя_файла_содержащего_словарь>"   # основной словарь
    $u = "c:\\dict\\user.dic"                # дополнительный

    Имя файла необходимо  заключать в кавычки,  а символы пути  -
экранировать.
    Длинные имена файлов работают только под Windows 95/98 (не MS
DOS или Windows NT);

         4.3.2. Задание используемых наборов символов.

    Далее обычно определяются  используемые наборы символов.  Они
делятся на предопределенные и задаваемые пользователем. Предопре-
деленные состоят из:

     $a - маленьких латинских букв, всего 26 штук;
     $A - больших латинских букв, всего 26 штук;
     $! - специальных знаков {}:"<>?[];\',./~!@#$%^&*()_+`-=\|  -
          32 штуки;
     $1 - цифр, 10 штук.

     Задаваемые пользователем состоят из:

     $i - маленьких букв национального алфавита;
     $I - больших букв национального алфавита;
     $o - дополнительного  набора (например, любые  не набираемые
на клавиатуре символы).

     Определение наборов происходит с помощью следующей конструк-
ции:

     $<набор> = [ <одиночные символы или наборы символов> ]

     Иначе говоря, набор символов записывается с помощью  объеди-
нения символов (см. п. 4.2.1), например:

     $i = [абвгдежзийклмнопрстуфхцчшщъыьэюяс]
     $o = [$! $1 \FF]

ПРИМЕЧАНИЯ:
    1) Определять  разрешается любые  наборы символов,  в т.ч.  и
предопределенные. Например, можно добавить во множество $! допол-
нительные символы, такие как пробел или \FF.
    2) Определение  множеств $i  и $I  автоматически определяет и
функции перевода в  нижний/верхний регистр. Поэтому  важно, чтобы
буквы в этих множествах шли в одном и том же порядке.
    Только после того, как все наборы символов определены,  обра-
зуется полное множество символов '?',  состоящее из [$a $A $1  $!
$i $I $o],  причем именно в  таком порядке -  это важно для  сле-
дующего пункта.

         4.3.3. Задание модификаторов преобразований.

    Далее могут задаваться модификаторы преобразований .c (см. п.
4.2.2), применительно к полному множеству символов ?. Это  дости-
гается с помощью строк вида

    ?.c(<номер>) = "<строка преобразования>"

    Каждый символ, имеющейся в полном множестве, преобразуется  в
соответствующий ему, находящийся в той же позиции в строке преоб-
разования. Например, пусть

    ?      = [1234567890], тогда
    ?.c(0) = "!@#$%^&*()"

задает преобразование, получаемое при нажатии Shift.
    В строке преобразования необходимо экранировать символы '\' и
'"'. Номера у модификаторов преобразования могут быть от 0 до 255.

          4.3.4. Задание специальных наборов символов

    К специальным наборам символов относятся:
    $v - множество гласных  букв (во всех алфавитах)  - требуется
только, если используются модификаторы .s и .j.
    $p - множество для вставки и замены при пермутационных  скоб-
ках - требуется только, если почему-то не устраивает автоматичес-
кое получение этого множества (см. п. 4.2.3).
    Они задаются аналогично остальным наборам символов.


            4.4. Полезные примеры описания паролей.

     1) Приведу отрывок из документации на программу ZEXPL2L:
     "Допустим,  что  Вы  имеете  архив  с  паролем,  похожим  на
"Heaven!!!", но забыли,  сколько восклицательных знаков  стояло в
конце слова, и какие - строчные/прописные - буквы были  использо-
ваны в слове :  "HeAvEn!!!", "Heaven!" или "HeAven!!!!".  Зато Вы
помните, что пароль был не длиннее, чем 10 символов, и не  короче
7."
     Этот пароль на языке PCL запишется так:
     "Нe [aA] v [eE] n ! *"  и опции -l7 -g10.
     Предположим дополнительно, что вы еще и ошиблись при  наборе
основной части пароля. Тогда стоит попробовать следующее:
     "{Нe [aA] v [eE] n} ! *" и -l7 -g10.

     2) Цитата оттуда же: "Допустим, Вы имеете два варианта стро-
ки пароля: "myprog", "MyProg", "my_prog" и "My_Prog".
     Это запишется как:
     "[mM] y [_ \0] [pP] rog".

     3) Часто  в качестве  пароля советуют  брать два осмысленных
слова, разделяя их каким-нибудь знаком. Соответствующее описание:
     "$w [$1 $!] $w"    или
     "$w.u(1) [$1 $!] $w.u(1)"
Важно отметить,  что оба  $w здесь  не равны  (это разные слова),
всего будет сгенерировано (если 20000 слов в словаре): 20000 * 42
* 20000 = 1.68E10 паролей, т.е. в среднем около 250 дней на  рас-
шифровку паролей, признанных  весьма трудно ломающимися.

     4) Излюбленные пароли у многих - русское слово, набранное на
клавиатуре на латинском регистре:
     "$w.c(0)" при задании соответствующей строки  преобразования
.c(0).

     5) Пароль ровно из шести русских букв:
     "$i $i $i $i $i $i".
Но эффективнее - "$i *" и опции -l6 -g6.

     6) Вы помните, что ваш пароль был  "MyVeryLongGoodPassword",
но он почему-то не подходит. Попробуйте такие комбинации:
     "{MyVeryLongGoodPassword}"   - 2382 пароля, 12 сек
     "{MyVeryLongGoodPassword}.2" - 2836413 пар., 4 часа

     7)  Вы  знаете,  что  пароль  состоит из осмысленного слова,
внутри которого на какой-то позиции вставлена цифра. Описание:

     $p = [$1]      # задаем множество вставки - цифры
     ##
     {$w}

     8) Атака по слогам. Создайте словарь допустимых слогов ваше-
го языка,  а затем  можно перебрать  все осмысленные  по звучанию
слова следующим образом:

     $u             # все односложные
     $u$u           # двусложные
     $u$u$u         # и т.д.
     $u$u$u$u
     ...

     9) Чтобы распараллелить работу  на 2 компьютера, задайте  им
следующие файлы описаний:
      "[abcdefghijklm] $a *" - первому
      "[nopqrstuvwxyz] $a *" - второму.
Аналогично поступайте для n компьютеров.

                   5. Возникающие проблемы (FAQ).

     1) Как прервать и продолжить счет дальше?

     Можно безболезненно прерывать программу после вывода  сообще-
ния "Testing XX-chars passwords..." и продолжать затем счет с по-
мощью опции -lXX (здесь оба XX равны).

     2) А как продолжить счет с пароля XXX?

     Пока никак. Это сделано в PCL 3.0, которая используется в
Parallel Password Recovery (http://www.parallelrecovery.com)

     3) Программа считает 10-й день, но ничего не нашла.

     Увы! Тут помочь можно мало чем. Либо пароль слишком  длинен,
либо он неправильно описан. Необходима дополнительная  информация
о пароле.

     4) В архиве файлы с разными паролями. Как найти их все?

     Просто  удалите  с  помощью  7-Zip тот  файл,  чей пароль уже
найден.

     5) Программа не работает с многотомными архивами.
     
     Соедините все части многотомного архива вместе, например,
командой 
     copy /b test.7z.001+test.7z.002+test.7z.033 test.7z

     6)  Я  проверил  Вашу  программу.  Так  вот, это просто одна
большая ошибка - она даже не определяет двухсимвольный пароль ти-
па "a2".

     RTFM. Файл password.def из дистрибутиве ведет перебор только
по маленьким латинским буквам.  Измените описание пароля на
"[$a $1] *" - и все будет ok.

     7) Я хочу попробовать оптимизировать Вашу программу. Можно
получить ее исходные тексты?

     Они Вам  не нужны.  Берите исходники  7-Zip и  оптимизируйте
функцию CKeyInfo::CalculateDigest().

     8) Как повысить скорость подбора по словарю?

     Отсортируйте слова в словаре по длине слова.

     9) Ваш дистрибутив сам запакован с паролем!!! Это не смешно!

     Раз Вы читаете этот файл. Вы разрешили эту проблему.

     10) Я хочу графический интерфейс, поддержку многих ядер, паузу/
восстановление и т.п.
     
     cRARk - это бесплатная утилита. Все, что Вам нужно, есть у
Parallel Password Recovery (http://www.parallelrecovery.com), лизензировавшая
механизм cRARk и PCL для своих продуктов.

     11) Что надо, чтобы использовать мою графическую карту для перебора
паролей?
     
     a) карта должна быть не ниже, чем NVIDIA GeForce серии 8 (при
этом некоторые ранние карты серии 8800 не поддерживаются) или не ниже, чем
AMD/ATI Radeon HD 5 серии.
     б) нужны последние драйвера. Лучше брать их отсюда:
http://www.nvidia.com/object/cuda_get.html или
http://support.amd.com/us/gpudownload/Pages/index.aspx
     в) в описании паролей должен быть символ '*'

     12) У меня возникают ошибки при работе программы на GPU.

     а) поставьте последние драйвера!
     б) не разгоняйте ни GPU, ни CPU
     в) на Windows Vista и 7, если выскакивает сообщение о том, что 
драйвер был установлен, запустите файл driver-timeout.reg из дистрибутива.


                        6. Выводы и перспективы.

     Система шифрования 7-zip является одной из лучших с точки
зрения скорости перебора из современных приложений, использующих
шифрование. Именно поэтому  у программы  такая малая скорость
перебора.
     На сегодняшний день не известны и крайне маловероятно, что
появятся методы, позволющие вскрывать 7-zip-архивы быстрее, чем
перебором.

                  8. Как связаться с автором.

     Только по e-mail.
     e-mail: pavel@semjanov.com
     WWW: http://www.semjanov.com

     Основной URL программы:
     http://www.crark.net/crark-7zip.html

     Окончательную и все последующие версии этой программы  можно
взять только  с указанного  WWW-сайта.
     Я буду благодарен  всем, кто ее  будет тестировать и  укажет
мне на явные ошибки, такие как:
     - программа  зависает при  переборе (то,  что она  ничего не
выводит при этом на экран, не является признаком зависания);
     - программа  не находит  такой-то пароль  в таком-то архиве,
хотя множество символов перебора задано верно:
     Так же буду рад любым конструктивным предложениям по улучше-
нию работы программы.


                          9. Спасибо.


     Игорю Павлову за 7-zip, LZMA SDK и их исходные коды;
     Andy Polyakov и другим разработчикам OpenSSL за некоторые идеи
оптимизации.
     всем остальным, кто помогал, советовал и тестировал cRARk.


                    Удачи!

                      P. Semjanov, St. Petersburg.
